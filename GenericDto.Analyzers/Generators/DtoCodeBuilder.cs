using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GenericDto.Analyzers.Constants;
using GenericDto.Analyzers.Extensions;
using GenericDto.Analyzers.Generators.Incremental;
using Microsoft.CodeAnalysis;

namespace GenericDto.Analyzers.Generators;

/// <summary>
/// Builder class responsible for generating DTO source code.
/// </summary>
internal static class DtoCodeBuilder
{
    public static string GenerateDto(DtoGenerationContext context)
    {
        var sb = new StringBuilder();
        var indent = new IndentedStringBuilder();

        // File header
        indent.AppendLine("// <auto-generated/>");
        indent.AppendLine("// This code was generated by GenericDto Source Generator.");
        indent.AppendLine("// Do not modify this file manually.");
        indent.AppendLine();
        indent.AppendLine("#nullable enable");
        indent.AppendLine();

        // Usings
        WriteUsings(indent, context);
        indent.AppendLine();

        // Namespace
        indent.AppendLine($"namespace {context.TargetNamespace}");
        indent.AppendLine("{");
        indent.IncreaseIndent();

        // Get attribute options
        var useRecord = context.GenerateDtoAttribute.GetNamedArgument<bool?>("UseRecord") ?? false;
        var accessModifier = context.GenerateDtoAttribute.GetNamedArgument<string>("AccessModifier") ?? "public";
        var implementIEquatable = context.GenerateDtoAttribute.GetNamedArgument<bool?>("ImplementIEquatable") ?? false;
        var implementIValidatableObject = context.GenerateDtoAttribute.GetNamedArgument<bool?>("ImplementIValidatableObject") ?? false;
        var generateParameterlessConstructor = context.GenerateDtoAttribute.GetNamedArgument<bool?>("GenerateParameterlessConstructor") ?? true;

        // Class/Record declaration
        WriteTypeDeclaration(indent, context, useRecord, accessModifier, implementIEquatable, implementIValidatableObject);
        indent.AppendLine("{");
        indent.IncreaseIndent();

        // Properties
        WriteProperties(indent, context);
        indent.AppendLine();

        // Constructors
        if (!useRecord)
        {
            WriteConstructors(indent, context, generateParameterlessConstructor);
        }

        // IEquatable implementation
        if (implementIEquatable && !useRecord)
        {
            WriteIEquatableImplementation(indent, context);
        }

        // IValidatableObject implementation
        if (implementIValidatableObject)
        {
            WriteIValidatableObjectImplementation(indent, context);
        }

        // ToString override
        if (!useRecord)
        {
            WriteToStringOverride(indent, context);
        }

        indent.DecreaseIndent();
        indent.AppendLine("}");

        indent.DecreaseIndent();
        indent.AppendLine("}");

        return indent.ToString();
    }

    private static void WriteUsings(IndentedStringBuilder sb, DtoGenerationContext context)
    {
        var usings = new HashSet<string>(GeneratorConstants.DefaultUsings);

        // Add source type namespace
        var sourceNamespace = context.SourceType.ContainingNamespace.ToDisplayString();
        if (!string.IsNullOrEmpty(sourceNamespace))
        {
            usings.Add(sourceNamespace);
        }

        // Add additional usings from attribute
        var additionalUsings = context.GenerateDtoAttribute.NamedArguments
            .FirstOrDefault(na => na.Key == "AdditionalUsings")
            .Value;

        if (!additionalUsings.IsNull && additionalUsings.Values.Length > 0)
        {
            foreach (var usingValue in additionalUsings.Values)
            {
                if (usingValue.Value is string usingStr)
                {
                    usings.Add(usingStr);
                }
            }
        }

        // Add IEquatable using if needed
        var implementIEquatable = context.GenerateDtoAttribute.GetNamedArgument<bool?>("ImplementIEquatable") ?? false;
        if (implementIEquatable)
        {
            usings.Add("System");
        }

        // Add IValidatableObject using if needed  
        var implementIValidatable = context.GenerateDtoAttribute.GetNamedArgument<bool?>("ImplementIValidatableObject") ?? false;
        if (implementIValidatable)
        {
            usings.Add("System.ComponentModel.DataAnnotations");
        }

        // Write sorted usings
        foreach (var usingStatement in usings.OrderBy(u => u))
        {
            sb.AppendLine($"using {usingStatement};");
        }
    }

    private static void WriteTypeDeclaration(
        IndentedStringBuilder sb, 
        DtoGenerationContext context, 
        bool useRecord, 
        string accessModifier,
        bool implementIEquatable,
        bool implementIValidatableObject)
    {
        var interfaces = new List<string>();

        if (implementIEquatable)
        {
            interfaces.Add($"global::System.IEquatable<{context.DtoClassName}>");
        }

        if (implementIValidatableObject)
        {
            interfaces.Add("global::System.ComponentModel.DataAnnotations.IValidatableObject");
        }

        var inheritance = interfaces.Count > 0 ? $" : {string.Join(", ", interfaces)}" : "";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// DTO class generated from <see cref=\"{context.SourceType.ToDisplayString()}\"/>.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"GenericDto.Analyzers\", \"1.0.0\")]");
        sb.AppendLine("[global::System.Diagnostics.DebuggerNonUserCodeAttribute]");
        sb.AppendLine("[global::System.Runtime.CompilerServices.CompilerGeneratedAttribute]");

        var typeKeyword = useRecord ? "record" : "partial class";
        sb.AppendLine($"{accessModifier} {typeKeyword} {context.DtoClassName}{inheritance}");
    }

    private static void WriteProperties(IndentedStringBuilder sb, DtoGenerationContext context)
    {
        foreach (var property in context.Properties)
        {
            // Add XML documentation
            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// Gets or sets the {property.PropertyName} value.");
            sb.AppendLine($"/// </summary>");

            // Add required attribute if property is non-nullable reference type
            if (property.IsRequired)
            {
                sb.AppendLine("[global::System.ComponentModel.DataAnnotations.Required]");
            }

            // Build property declaration
            var typeStr = property.PropertyType;
            if (property.IsNullable && !typeStr.EndsWith("?"))
            {
                typeStr += "?";
            }

            var propertyDeclaration = $"public {typeStr} {property.PropertyName} {{ get; set; }}";

            if (property.HasDefaultValue && property.DefaultValue != null)
            {
                propertyDeclaration += $" = {property.DefaultValue};";
            }
            else if (property.IsNullable)
            {
                propertyDeclaration += " = default!;";
            }
            else if (IsStringType(property.PropertyType))
            {
                propertyDeclaration += " = string.Empty;";
            }

            sb.AppendLine(propertyDeclaration);
            sb.AppendLine();
        }
    }

    private static bool IsStringType(string propertyType)
    {
        return propertyType == "string" || 
               propertyType == "global::System.String" || 
               propertyType == "System.String";
    }

    private static void WriteConstructors(IndentedStringBuilder sb, DtoGenerationContext context, bool generateParameterless)
    {
        if (generateParameterless)
        {
            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// Initializes a new instance of the <see cref=\"{context.DtoClassName}\"/> class.");
            sb.AppendLine($"/// </summary>");
            sb.AppendLine($"public {context.DtoClassName}()");
            sb.AppendLine("{");
            sb.AppendLine("}");
            sb.AppendLine();
        }

        // Generate constructor with all properties
        if (context.Properties.Count > 0)
        {
            sb.AppendLine($"/// <summary>");
            sb.AppendLine($"/// Initializes a new instance of the <see cref=\"{context.DtoClassName}\"/> class with specified values.");
            sb.AppendLine($"/// </summary>");

            var parameters = context.Properties
                .Select(p =>
                {
                    var type = p.IsNullable && !p.PropertyType.EndsWith("?") ? $"{p.PropertyType}?" : p.PropertyType;
                    var paramName = p.PropertyName.ToCamelCase();
                    return $"{type} {paramName}";
                });

            sb.AppendLine($"public {context.DtoClassName}({string.Join(", ", parameters)})");
            sb.AppendLine("{");
            sb.IncreaseIndent();

            foreach (var property in context.Properties)
            {
                var paramName = property.PropertyName.ToCamelCase();
                sb.AppendLine($"this.{property.PropertyName} = {paramName};");
            }

            sb.DecreaseIndent();
            sb.AppendLine("}");
            sb.AppendLine();
        }
    }

    private static void WriteIEquatableImplementation(IndentedStringBuilder sb, DtoGenerationContext context)
    {
        sb.AppendLine("/// <inheritdoc/>");
        sb.AppendLine($"public bool Equals({context.DtoClassName}? other)");
        sb.AppendLine("{");
        sb.IncreaseIndent();
        sb.AppendLine("if (other is null) return false;");
        sb.AppendLine("if (ReferenceEquals(this, other)) return true;");

        if (context.Properties.Count > 0)
        {
            var comparisons = context.Properties
                .Select(p => $"global::System.Collections.Generic.EqualityComparer<{p.PropertyType}>.Default.Equals({p.PropertyName}, other.{p.PropertyName})");

            sb.AppendLine($"return {string.Join(" && ", comparisons)};");
        }
        else
        {
            sb.AppendLine("return true;");
        }

        sb.DecreaseIndent();
        sb.AppendLine("}");
        sb.AppendLine();

        // Override Equals(object)
        sb.AppendLine("/// <inheritdoc/>");
        sb.AppendLine("public override bool Equals(object? obj)");
        sb.AppendLine("{");
        sb.IncreaseIndent();
        sb.AppendLine($"return obj is {context.DtoClassName} other && Equals(other);");
        sb.DecreaseIndent();
        sb.AppendLine("}");
        sb.AppendLine();

        // Override GetHashCode
        sb.AppendLine("/// <inheritdoc/>");
        sb.AppendLine("public override int GetHashCode()");
        sb.AppendLine("{");
        sb.IncreaseIndent();

        if (context.Properties.Count > 0)
        {
            sb.AppendLine("var hash = new global::System.HashCode();");
            foreach (var property in context.Properties)
            {
                sb.AppendLine($"hash.Add({property.PropertyName});");
            }
            sb.AppendLine("return hash.ToHashCode();");
        }
        else
        {
            sb.AppendLine("return 0;");
        }

        sb.DecreaseIndent();
        sb.AppendLine("}");
        sb.AppendLine();

        // Equality operators
        sb.AppendLine($"public static bool operator ==({context.DtoClassName}? left, {context.DtoClassName}? right)");
        sb.AppendLine("{");
        sb.IncreaseIndent();
        sb.AppendLine("return global::System.Collections.Generic.EqualityComparer<" + context.DtoClassName + ">.Default.Equals(left, right);");
        sb.DecreaseIndent();
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine($"public static bool operator !=({context.DtoClassName}? left, {context.DtoClassName}? right)");
        sb.AppendLine("{");
        sb.IncreaseIndent();
        sb.AppendLine("return !(left == right);");
        sb.DecreaseIndent();
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void WriteIValidatableObjectImplementation(IndentedStringBuilder sb, DtoGenerationContext context)
    {
        sb.AppendLine("/// <inheritdoc/>");
        sb.AppendLine("public global::System.Collections.Generic.IEnumerable<global::System.ComponentModel.DataAnnotations.ValidationResult> Validate(global::System.ComponentModel.DataAnnotations.ValidationContext validationContext)");
        sb.AppendLine("{");
        sb.IncreaseIndent();

        // Add validation for required properties
        foreach (var property in context.Properties.Where(p => p.IsRequired))
        {
            sb.AppendLine($"if ({property.PropertyName} is null)");
            sb.AppendLine("{");
            sb.IncreaseIndent();
            sb.AppendLine($"yield return new global::System.ComponentModel.DataAnnotations.ValidationResult(\"{property.PropertyName} is required.\", new[] {{ nameof({property.PropertyName}) }});");
            sb.DecreaseIndent();
            sb.AppendLine("}");
            sb.AppendLine();
        }

        sb.AppendLine("yield break;");
        sb.DecreaseIndent();
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static void WriteToStringOverride(IndentedStringBuilder sb, DtoGenerationContext context)
    {
        sb.AppendLine("/// <inheritdoc/>");
        sb.AppendLine("public override string ToString()");
        sb.AppendLine("{");
        sb.IncreaseIndent();

        if (context.Properties.Count > 0)
        {
            var propertyStrings = context.Properties
                .Select(p => $"{p.PropertyName} = {{{p.PropertyName}}}");
            sb.AppendLine($"return $\"{context.DtoClassName} {{ {string.Join(", ", propertyStrings)} }}\";");
        }
        else
        {
            sb.AppendLine($"return \"{context.DtoClassName}\";");
        }

        sb.DecreaseIndent();
        sb.AppendLine("}");
    }
}

/// <summary>
/// Helper class for building indented string content.
/// </summary>
internal sealed class IndentedStringBuilder
{
    private readonly StringBuilder _sb = new();
    private int _indentLevel;
    private const string IndentString = "    ";

    public void IncreaseIndent() => _indentLevel++;
    public void DecreaseIndent() => _indentLevel = Math.Max(0, _indentLevel - 1);

    public void AppendLine(string? text = null)
    {
        if (string.IsNullOrEmpty(text))
        {
            _sb.AppendLine();
        }
        else
        {
            _sb.Append(GetIndent());
            _sb.AppendLine(text);
        }
    }

    public void Append(string text)
    {
        _sb.Append(text);
    }

    private string GetIndent()
    {
        return string.Concat(Enumerable.Repeat(IndentString, _indentLevel));
    }

    public override string ToString() => _sb.ToString();
}
