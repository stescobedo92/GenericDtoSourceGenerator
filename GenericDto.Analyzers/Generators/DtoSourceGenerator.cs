using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using GenericDto.Analyzers.Constants;
using GenericDto.Analyzers.Extensions;
using GenericDto.Analyzers.Generators.Incremental;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace GenericDto.Analyzers.Generators;

/// <summary>
/// Incremental source generator that generates DTO classes from types marked with [GenericDto] attribute.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DtoSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute source (embedded in the generator output)
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "GenericDtoAttributeMarker.g.cs",
            SourceText.From(GenerateAttributeMarker(), Encoding.UTF8)));

        // Create a provider for types with the GenericDto attribute using CreateSyntaxProvider
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateForGeneration(node),
                transform: static (ctx, ct) => GetDtoGenerationContextFromSyntax(ctx, ct))
            .Where(static m => m is not null)
            .Select(static (m, _) => m!.Value);

        // Combine with compilation
        var compilationAndTypes = context.CompilationProvider.Combine(typeDeclarations.Collect());

        // Register the source output
        context.RegisterSourceOutput(compilationAndTypes, static (spc, source) => Execute(source.Left, source.Right, spc));
    }

    private static bool IsCandidateForGeneration(SyntaxNode node)
    {
        // Check if the node is a type declaration with attributes
        if (node is not TypeDeclarationSyntax typeDeclaration)
            return false;

        // Must have attributes
        if (typeDeclaration.AttributeLists.Count == 0)
            return false;

        // Check if any attribute looks like GenericDto
        foreach (var attributeList in typeDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var name = attribute.Name.ToString();
                if (name == "GenericDto" || name == "GenericDtoAttribute" || 
                    name.EndsWith(".GenericDto") || name.EndsWith(".GenericDtoAttribute"))
                {
                    return true;
                }
            }
        }

        return false;
    }

    private static DtoGenerationContext? GetDtoGenerationContextFromSyntax(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration, cancellationToken) as INamedTypeSymbol;
        if (typeSymbol is null)
            return null;

        // Find the GenericDto attribute
        var attribute = typeSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == GeneratorConstants.GenericDtoCoreAttributeFullName);

        if (attribute is null)
            return null;

        // Extract attribute values
        var dtoName = attribute.GetNamedArgument<string>("DtoName");
        var targetNamespace = attribute.GetNamedArgument<string>("Namespace");
        var useRecord = attribute.GetNamedArgument<bool?>("UseRecord") ?? false;
        var accessModifier = attribute.GetNamedArgument<string>("AccessModifier") ?? "public";
        var generateParameterlessConstructor = attribute.GetNamedArgument<bool?>("GenerateParameterlessConstructor") ?? true;
        var implementIEquatable = attribute.GetNamedArgument<bool?>("ImplementIEquatable") ?? false;
        var implementIValidatableObject = attribute.GetNamedArgument<bool?>("ImplementIValidatableObject") ?? false;

        // Determine DTO name
        var finalDtoName = string.IsNullOrWhiteSpace(dtoName)
            ? typeSymbol.Name + GeneratorConstants.DtoSuffix
            : dtoName;

        // Determine namespace
        var finalNamespace = string.IsNullOrWhiteSpace(targetNamespace)
            ? typeSymbol.ContainingNamespace.ToDisplayString() + GeneratorConstants.DtoNamespaceSuffix
            : targetNamespace;

        // Collect properties
        var properties = CollectProperties(typeSymbol, cancellationToken);

        return new DtoGenerationContext(
            typeSymbol,
            attribute,
            finalNamespace!,
            finalDtoName!,
            properties);
    }

    private static string GenerateAttributeMarker()
    {
        return @"// <auto-generated/>
// This file was generated by GenericDto Source Generator

[assembly: GenericDto.Analyzers.GenericDtoGeneratedAttribute]

namespace GenericDto.Analyzers
{
    [global::System.AttributeUsage(global::System.AttributeTargets.Assembly)]
    internal sealed class GenericDtoGeneratedAttribute : global::System.Attribute { }
}
";
    }

    private static List<PropertyContext> CollectProperties(INamedTypeSymbol typeSymbol, CancellationToken cancellationToken)
    {
        var properties = new List<PropertyContext>();
        var processedNames = new HashSet<string>(StringComparer.Ordinal);

        // Get properties from the type and its base types
        var currentType = typeSymbol;
        while (currentType != null && currentType.SpecialType != SpecialType.System_Object)
        {
            cancellationToken.ThrowIfCancellationRequested();

            foreach (var member in currentType.GetMembers())
            {
                if (member is not IPropertySymbol propertySymbol)
                    continue;

                // Skip if already processed (overridden properties)
                if (!processedNames.Add(propertySymbol.Name))
                    continue;

                // Skip if property should be ignored
                if (ShouldIgnoreProperty(propertySymbol))
                    continue;

                // Skip non-public properties, static properties, indexers
                if (propertySymbol.DeclaredAccessibility != Accessibility.Public ||
                    propertySymbol.IsStatic ||
                    propertySymbol.IsIndexer)
                    continue;

                // Skip write-only properties
                if (propertySymbol.GetMethod is null)
                    continue;

                var propertyContext = CreatePropertyContext(propertySymbol);
                properties.Add(propertyContext);
            }

            currentType = currentType.BaseType;
        }

        return properties;
    }

    private static bool ShouldIgnoreProperty(IPropertySymbol property)
    {
        // Check for DtoIgnore attribute
        if (property.HasAttribute(GeneratorConstants.DtoIgnoreAttributeFullName))
            return true;

        // Check for DtoProperty attribute with Ignore = true
        var dtoPropertyAttr = property.GetAttribute(GeneratorConstants.DtoPropertyAttributeFullName);
        if (dtoPropertyAttr != null)
        {
            var ignore = dtoPropertyAttr.GetNamedArgument<bool?>("Ignore");
            if (ignore == true)
                return true;
        }

        return false;
    }

    private static PropertyContext CreatePropertyContext(IPropertySymbol property)
    {
        var dtoPropertyAttr = property.GetAttribute(GeneratorConstants.DtoPropertyAttributeFullName);

        // Get custom name from attribute or use original name
        var propertyName = dtoPropertyAttr?.GetNamedArgument<string>("Name") ?? property.Name;

        // Get the type representation
        var propertyType = GetPropertyTypeString(property.Type, dtoPropertyAttr);

        // Check nullability - ForceNullable is now an enum: 0 = Inherit, 1 = True, 2 = False
        var forceNullableValue = dtoPropertyAttr?.GetNamedArgument<int?>("ForceNullable");
        bool isNullable;
        if (forceNullableValue.HasValue && forceNullableValue.Value == 1) // NullableOption.True
        {
            isNullable = true;
        }
        else if (forceNullableValue.HasValue && forceNullableValue.Value == 2) // NullableOption.False
        {
            isNullable = false;
        }
        else // NullableOption.Inherit or not specified
        {
            isNullable = property.Type.IsNullable();
        }

        // Get default value
        var defaultValue = dtoPropertyAttr?.GetNamedArgument<string>("DefaultValue");
        var hasDefaultValue = !string.IsNullOrEmpty(defaultValue);

        // Determine if property is required (non-nullable without default value)
        var isRequired = !isNullable && !hasDefaultValue && !property.Type.IsValueType;

        // Determine if property is read-only (no setter)
        var isReadOnly = property.SetMethod is null;

        return new PropertyContext(
            propertyName,
            propertyType,
            isNullable,
            hasDefaultValue,
            defaultValue,
            isRequired,
            isReadOnly,
            property);
    }

    private static string GetPropertyTypeString(ITypeSymbol type, AttributeData? dtoPropertyAttr)
    {
        // Check if custom type is specified
        if (dtoPropertyAttr != null)
        {
            var customType = dtoPropertyAttr.NamedArguments
                .FirstOrDefault(na => na.Key == "Type")
                .Value;

            if (!customType.IsNull && customType.Value is INamedTypeSymbol customTypeSymbol)
            {
                return customTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            }
        }

        return type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    private static void Execute(Compilation compilation, ImmutableArray<DtoGenerationContext> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
            return;

        // Track generated DTO names to detect duplicates
        var generatedDtos = new Dictionary<string, DtoGenerationContext>();

        foreach (var dtoContext in types)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            var fullName = $"{dtoContext.TargetNamespace}.{dtoContext.DtoClassName}";

            // Check for duplicate DTO names
            if (generatedDtos.TryGetValue(fullName, out var existing))
            {
                var diagnostic = Diagnostic.Create(
                    Diagnostics.DiagnosticDescriptors.DuplicateDtoName,
                    dtoContext.SourceType.Locations.FirstOrDefault(),
                    dtoContext.DtoClassName);
                context.ReportDiagnostic(diagnostic);
                continue;
            }

            generatedDtos[fullName] = dtoContext;

            // Generate the DTO code
            var code = DtoCodeBuilder.GenerateDto(dtoContext);
            var fileName = $"{dtoContext.TargetNamespace}.{dtoContext.DtoClassName}.g.cs";
            context.AddSource(fileName, SourceText.From(code, Encoding.UTF8));

            // Generate mapper extension methods
            var mapperCode = MapperCodeBuilder.GenerateMapper(dtoContext);
            var mapperFileName = $"{dtoContext.TargetNamespace}.{dtoContext.DtoClassName}Mapper.g.cs";
            context.AddSource(mapperFileName, SourceText.From(mapperCode, Encoding.UTF8));
        }
    }
}
